#!/usr/bin/env python3
"""
OIC Newsletter Generator
========================

Automatischer Newsletter-Generator f√ºr OIC Beitr√§ge.
Scannt _beitraege/ Verzeichnis und erstellt Newsletter aus ausgew√§hlten Beitr√§gen.

Usage:
    python newsletter-generator.py

Author: OIC Bielefeld Team
"""

import os
import sys
import yaml
import re
from datetime import datetime, date
from pathlib import Path
from typing import List, Dict, Optional
import argparse

class NewsletterGenerator:
    def __init__(self, base_path: str = "."):
        self.base_path = Path(base_path)
        self.beitraege_path = self.base_path / "_beitraege"
        self.output_path = self.base_path / "_site" / "newsletter"
        self.template_path = self.base_path / "newsletter-template.html"
        
        # Stelle sicher, dass Output-Verzeichnis existiert
        self.output_path.mkdir(parents=True, exist_ok=True)
    
    def parse_front_matter(self, content: str) -> tuple[Dict, str]:
        """Extrahiert YAML Front Matter aus Markdown-Datei."""
        if not content.startswith('---'):
            return {}, content
        
        try:
            # Front Matter extrahieren
            parts = content.split('---', 2)
            if len(parts) < 3:
                return {}, content
            
            front_matter = yaml.safe_load(parts[1])
            markdown_content = parts[2].strip()
            
            return front_matter or {}, markdown_content
        except yaml.YAMLError as e:
            print(f"‚ùå YAML Parse Error: {e}")
            return {}, content
    
    def get_all_posts(self) -> List[Dict]:
        """L√§dt alle Beitr√§ge aus _beitraege/ Verzeichnis."""
        posts = []
        
        if not self.beitraege_path.exists():
            print(f"‚ùå Beitr√§ge-Verzeichnis nicht gefunden: {self.beitraege_path}")
            return posts
        
        for file_path in self.beitraege_path.glob("*.md"):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                front_matter, markdown_content = self.parse_front_matter(content)
                
                if not front_matter:
                    continue
                
                # Post-Daten sammeln
                post = {
                    'file_path': file_path,
                    'filename': file_path.stem,
                    'title': front_matter.get('title', file_path.stem),
                    'teaser': front_matter.get('teaser', ''),
                    'author': front_matter.get('author', ''),
                    'category': front_matter.get('category', ''),
                    'date': front_matter.get('date', ''),
                    'content': markdown_content,
                    'url': f"/beitraege/{file_path.stem}/"
                }
                
                # Datum parsen
                if post['date']:
                    if isinstance(post['date'], date):
                        post['date_obj'] = post['date']
                    else:
                        try:
                            post['date_obj'] = datetime.strptime(str(post['date']), '%Y-%m-%d').date()
                        except ValueError:
                            post['date_obj'] = None
                else:
                    post['date_obj'] = None
                
                posts.append(post)
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Fehler beim Lesen von {file_path}: {e}")
        
        # Nach Datum sortieren (neueste zuerst)
        posts.sort(key=lambda x: x['date_obj'] or date.min, reverse=True)
        return posts
    
    def filter_posts_by_date(self, posts: List[Dict], since_date: date) -> List[Dict]:
        """Filtert Posts nach Datum."""
        filtered = []
        for post in posts:
            if post['date_obj'] and post['date_obj'] >= since_date:
                filtered.append(post)
        return filtered
    
    def interactive_post_selection(self, posts: List[Dict]) -> List[Dict]:
        """Interaktive Auswahl der Posts f√ºr den Newsletter."""
        if not posts:
            print("‚ùå Keine Beitr√§ge gefunden!")
            return []
        
        print(f"\nüìÑ Verf√ºgbare Beitr√§ge ({len(posts)}):")
        print("=" * 60)
        
        for i, post in enumerate(posts, 1):
            date_str = post['date_obj'].strftime('%d.%m.%Y') if post['date_obj'] else 'Kein Datum'
            print(f"[{i:2d}] {post['title']}")
            print(f"     üìÖ {date_str} | üë§ {post['author']} | üè∑Ô∏è  {post['category']}")
            if post['teaser']:
                teaser = post['teaser'][:80] + "..." if len(post['teaser']) > 80 else post['teaser']
                print(f"     üí≠ {teaser}")
            print()
        
        print("Auswahl-Optionen:")
        print("‚Ä¢ Einzelne Nummern: 1,3,5")
        print("‚Ä¢ Bereiche: 1-3")
        print("‚Ä¢ Alle: 'all' oder 'alle'")
        print("‚Ä¢ Keine: 'none' oder Enter")
        
        while True:
            selection = input("\n‚û§ Beitr√§ge ausw√§hlen: ").strip()
            
            if not selection or selection.lower() in ['none', 'keine']:
                return []
            
            if selection.lower() in ['all', 'alle']:
                return posts
            
            try:
                selected_indices = set()
                
                # Parse Auswahl
                parts = selection.split(',')
                for part in parts:
                    part = part.strip()
                    if '-' in part:
                        # Bereich: 1-3
                        start, end = map(int, part.split('-'))
                        selected_indices.update(range(start, end + 1))
                    else:
                        # Einzelne Nummer
                        selected_indices.add(int(part))
                
                # Validierung
                invalid = [i for i in selected_indices if i < 1 or i > len(posts)]
                if invalid:
                    print(f"‚ùå Ung√ºltige Nummern: {invalid}")
                    continue
                
                # Posts ausw√§hlen
                selected_posts = [posts[i-1] for i in sorted(selected_indices)]
                
                print(f"\n‚úÖ {len(selected_posts)} Beitr√§ge ausgew√§hlt:")
                for post in selected_posts:
                    print(f"   ‚Ä¢ {post['title']}")
                
                return selected_posts
                
            except ValueError:
                print("‚ùå Ung√ºltige Eingabe! Bitte Zahlen, Bereiche oder 'all' verwenden.")
    
    def load_newsletter_template(self) -> str:
        """L√§dt das Newsletter-Template."""
        try:
            with open(self.template_path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            print(f"‚ùå Newsletter-Template nicht gefunden: {self.template_path}")
            sys.exit(1)
    
    def generate_newsletter_content(self, selected_posts: List[Dict]) -> str:
        """Generiert Newsletter-Content aus ausgew√§hlten Posts."""
        if not selected_posts:
            return ""
        
        # Header-Infos
        current_date = datetime.now().strftime("%B %Y")
        months_de = {
            'January': 'Januar', 'February': 'Februar', 'March': 'M√§rz',
            'April': 'April', 'May': 'Mai', 'June': 'Juni',
            'July': 'Juli', 'August': 'August', 'September': 'September',
            'October': 'Oktober', 'November': 'November', 'December': 'Dezember'
        }
        for en, de in months_de.items():
            current_date = current_date.replace(en, de)
        
        # Newsletter-Inhalt generieren
        content_sections = []
        
        for i, post in enumerate(selected_posts, 1):
            # Abschnitt f√ºr jeden Post
            section = f"""
            <h3 style="margin: 30px 0 15px 0; color: #666cde; font-size: 20px; font-weight: 600;">
                {post['title']}
            </h3>
            <p style="margin: 0 0 20px 0; color: #2c3e50; font-size: 16px; line-height: 1.6;">
                {post['teaser']}
            </p>
            """
            
            # Call-to-Action Button f√ºr jeden Post
            if post['url']:
                section += f"""
                <table role="presentation" cellspacing="0" cellpadding="0" border="0" style="margin: 25px 0;">
                    <tr>
                        <td style="border-radius: 25px; background: linear-gradient(135deg, #00b2bb 0%, #666cde 100%); text-align: center;">
                            <a href="https://oic-bielefeld.de{post['url']}" style="display: inline-block; padding: 12px 30px; color: #ffffff; text-decoration: none; font-weight: 600; font-size: 16px; border-radius: 25px;">
                                Beitrag lesen
                            </a>
                        </td>
                    </tr>
                </table>
                """
            
            # Meta-Informationen
            date_str = post['date_obj'].strftime('%d.%m.%Y') if post['date_obj'] else ''
            meta_info = []
            if date_str:
                meta_info.append(f"üìÖ {date_str}")
            if post['author']:
                meta_info.append(f"üë§ {post['author']}")
            if post['category']:
                meta_info.append(f"üè∑Ô∏è {post['category']}")
            
            if meta_info:
                section += f"""
                <p style="margin: 0 0 20px 0; color: #666; font-size: 14px; font-style: italic;">
                    {' | '.join(meta_info)}
                </p>
                """
            
            content_sections.append(section)
        
        # Zusammenfassung generieren
        intro_text = f"""
        Liebe Innovationsbegeisterte,
        
        herzlich willkommen zu unserem Newsletter f√ºr {current_date}! 
        Wir haben {len(selected_posts)} spannende Beitr√§ge aus der Welt der offenen Innovation f√ºr Sie zusammengestellt.
        """
        
        closing_text = f"""
        Das waren unsere Highlights f√ºr {current_date}. Wir hoffen, Sie fanden die Beitr√§ge interessant und inspirierend!
        
        Haben Sie Fragen oder Anregungen? Sprechen Sie uns gerne an.
        """
        
        return {
            'date': current_date,
            'intro': intro_text.strip(),
            'sections': ''.join(content_sections),
            'closing': closing_text.strip(),
            'title': f"OIC Newsletter {current_date}"
        }
    
    def generate_newsletter_html(self, selected_posts: List[Dict]) -> str:
        """Generiert vollst√§ndige Newsletter-HTML."""
        template = self.load_newsletter_template()
        content_data = self.generate_newsletter_content(selected_posts)
        
        if not content_data:
            return template
        
        # Template-Platzhalter ersetzen
        newsletter_html = template
        
        # Datum
        newsletter_html = newsletter_html.replace('[DATUM - z.B. Juni 2024]', content_data['date'])
        
        # Haupt√ºberschrift
        newsletter_html = newsletter_html.replace('[HAUPT√úBERSCHRIFT]', content_data['title'])
        
        # Einleitungstext
        newsletter_html = newsletter_html.replace('[EINLEITUNGSTEXT - Begr√º√üung und kurze Einf√ºhrung in die Newsletter-Ausgabe]', content_data['intro'])
        
        # Content-Bereiche durch generierten Inhalt ersetzen
        # Wir ersetzen den ganzen mittleren Bereich
        start_marker = '<!-- Section 1 -->'
        end_marker = '<!-- Closing -->'
        
        start_pos = newsletter_html.find(start_marker)
        end_pos = newsletter_html.find(end_marker)
        
        if start_pos != -1 and end_pos != -1:
            before = newsletter_html[:start_pos]
            after = newsletter_html[end_pos:]
            
            newsletter_html = before + content_data['sections'] + '\n            <!-- Closing -->' + after
        
        # Abschlusstext
        newsletter_html = newsletter_html.replace('[ABSCHLUSSTEXT - Verabschiedung und Ausblick]', content_data['closing'])
        
        return newsletter_html
    
    def save_newsletter(self, html_content: str, filename: str = None) -> str:
        """Speichert Newsletter als HTML-Datei."""
        if not filename:
            timestamp = datetime.now().strftime('%Y-%m')
            filename = f"newsletter-{timestamp}.html"
        
        output_file = self.output_path / filename
        
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            return str(output_file)
        except Exception as e:
            print(f"‚ùå Fehler beim Speichern: {e}")
            return ""
    
    def run(self, since_days: int = 30):
        """Hauptfunktion - F√ºhrt den Newsletter-Generator aus."""
        print("üöÄ OIC Newsletter Generator")
        print("=" * 40)
        
        # 1. Posts laden
        print("üìÅ Lade Beitr√§ge...")
        all_posts = self.get_all_posts()
        
        if not all_posts:
            print("‚ùå Keine Beitr√§ge gefunden!")
            return
        
        print(f"‚úÖ {len(all_posts)} Beitr√§ge gefunden")
        
        # 2. Datum-Filter
        since_date = date.today().replace(day=1)  # Erster Tag des aktuellen Monats
        if since_days:
            from datetime import timedelta
            since_date = date.today() - timedelta(days=since_days)
        
        print(f"üóìÔ∏è  Suche Beitr√§ge seit: {since_date.strftime('%d.%m.%Y')}")
        
        recent_posts = self.filter_posts_by_date(all_posts, since_date)
        
        if not recent_posts:
            print(f"‚ùå Keine Beitr√§ge seit {since_date.strftime('%d.%m.%Y')} gefunden!")
            print("üí° Verwenden Sie --since-days um den Zeitraum zu erweitern")
            return
        
        print(f"‚úÖ {len(recent_posts)} aktuelle Beitr√§ge gefunden")
        
        # 3. Interaktive Auswahl
        selected_posts = self.interactive_post_selection(recent_posts)
        
        if not selected_posts:
            print("‚ùå Keine Beitr√§ge ausgew√§hlt. Newsletter-Generierung abgebrochen.")
            return
        
        # 4. Newsletter generieren
        print(f"\nüîÑ Generiere Newsletter mit {len(selected_posts)} Beitr√§gen...")
        newsletter_html = self.generate_newsletter_html(selected_posts)
        
        # 5. Speichern
        output_file = self.save_newsletter(newsletter_html)
        
        if output_file:
            print(f"\n‚úÖ Newsletter erfolgreich generiert!")
            print(f"üìÑ Datei: {output_file}")
            print(f"üåê URL: /newsletter/{Path(output_file).name}")
            print(f"\nüí° Tipp: √ñffnen Sie die Datei in einem Browser zur Vorschau")
        else:
            print("‚ùå Fehler beim Speichern des Newsletters")

def main():
    """CLI Entry Point."""
    parser = argparse.ArgumentParser(description='OIC Newsletter Generator')
    parser.add_argument('--since-days', type=int, default=30,
                       help='Beitr√§ge der letzten N Tage ber√ºcksichtigen (Standard: 30)')
    parser.add_argument('--base-path', type=str, default='.',
                       help='Basis-Pfad der Jekyll-Website (Standard: aktuelles Verzeichnis)')
    
    args = parser.parse_args()
    
    # Generator erstellen und ausf√ºhren
    generator = NewsletterGenerator(args.base_path)
    generator.run(args.since_days)

if __name__ == '__main__':
    main()